// Load environment variables from .env file
require('dotenv').config();

const WebSocket = require('ws');
const { createClient, LiveTranscriptionEvents } = require("@deepgram/sdk");
const crypto = require('crypto');

// Configuration
const port = process.env.PORT || 8080;
const MAX_CONNECTIONS = parseInt(process.env.MAX_CONNECTIONS) || 100;
const MAX_MESSAGE_SIZE = parseInt(process.env.MAX_MESSAGE_SIZE) || 1024 * 1024; // 1MB default
// STT tuning and safety defaults (override via env)
const DEFAULT_MODEL = process.env.DG_MODEL || process.env.DEEPGRAM_MODEL || 'nova-3';
const STT_LANGUAGE = process.env.STT_LANGUAGE || process.env.DG_LANGUAGE || 'en';
const ENDPOINTING_MS = parseInt(process.env.ENDPOINTING_MS || '350');
const UTTERANCE_END_MS = parseInt(process.env.UTTERANCE_END_MS || '1500');
const MIN_FINAL_CONFIDENCE = parseFloat(process.env.MIN_FINAL_CONFIDENCE || '0.65');
const MAX_AUDIO_BUFFER_SIZE = parseInt(process.env.MAX_AUDIO_BUFFER_SIZE || String(64 * 1024)); // 64KB per chunk
const MAX_KEYTERMS = parseInt(process.env.MAX_KEYTERMS || '40');

// Connection tracking for security
let currentConnections = 0;

// Add finalization tracking
const finalizationPending = new Map(); // Track sessions waiting for finalization
const finalizationTimeouts = new Map(); // Track timeouts for each session

// Parse allowed origins from environment variable or use defaults
const defaultOrigins = [
  'https://vrplaced-profiling-git-deepgramstt-mythya-verse.vercel.app',
  'http://localhost:3000',
  'http://127.0.0.1:3000'
];

const allowedOrigins = process.env.ALLOWED_ORIGINS 
  ? process.env.ALLOWED_ORIGINS.split(',').map(origin => origin.trim())
  : defaultOrigins;

const deepgramApiKey = process.env.DEEPGRAM_API_KEY || process.env.DeepGram_API_Key;
if (!deepgramApiKey) {
  console.error('âŒ CRITICAL: Deepgram API key not configured!');
  console.error('Please set either DEEPGRAM_API_KEY or DeepGram_API_Key environment variable');
  process.exit(1);
}

// Store active Deepgram connections
const deepgramConnections = new Map();

// Function to send finalization complete signal
const sendFinalizationComplete = (sessionId, ws) => {
  console.log(`ðŸŽ‰ Sending finalization complete for session: ${sessionId}`);
  
  // Clear timeout
  const timeout = finalizationTimeouts.get(sessionId);
  if (timeout) {
    clearTimeout(timeout);
    finalizationTimeouts.delete(sessionId);
  }
  
  // Remove from pending
  finalizationPending.delete(sessionId);
  
  // Send completion signal to client
  ws.send(JSON.stringify({
    type: 'finalization_complete',
    sessionId,
    message: 'All final transcripts have been sent',
    timestamp: Date.now()
  }));
};

// Default keywords focused on Node.js interview skills + company/project names
const defaultKeywords = process.env.DEFAULT_KEYWORDS 
  ? process.env.DEFAULT_KEYWORDS.split(',').map(kw => kw.trim())
  : [
      'VRPlaced',
      'MythyaVerse',
      'HR Connect',
      'Shadev',
      'Shadev Kumar',
      'Sumit',
      'Express.js',
      'ExpressJS',
      'Node.js',
      'NodeJS',
      'JavaScript',
      'NestJS',
      'Fastify',
      'Koa',
      'Socket.io',
      'PM2',
      'Node.js',
      'Prisma',
      'TypeORM',
      'Sequelize',
      'Mongoose',
      'PostgreSQL',
      'MongoDB',
      'Redis',
      'BullMQ',
      'Kafka',
      'RabbitMQ',
      'Docker',
      'OpenAPI',
      'Swagger',
      'Zod',
      'Joi',
      'JWT',
      'bcrypt',
      'Jest',
      'Supertest',
      'Winston',
      'Morgan',
      'EventEmitter',
      'N-API',
      'V8'
    ];

console.log('ðŸš€ Starting VRPlaced STT WebSocket Server...');
console.log(`ðŸ“¡ Port: ${port}`);
// console.log(`ðŸŒ Allowed Origins ${process.env.ALLOWED_ORIGINS ? '(from env)' : '(defaults)'}: ${allowedOrigins.join(', ')}`);
// console.log(`ðŸŽ¯ Keywords ${process.env.DEFAULT_KEYWORDS ? '(from env)' : '(defaults)'}: ${defaultKeywords.join(', ')}`);
// console.log(`ðŸ§  Model: ${DEFAULT_MODEL}, Language: ${STT_LANGUAGE}, Endpointing: ${ENDPOINTING_MS}ms, UtteranceEnd: ${UTTERANCE_END_MS}ms`);

// Create WebSocket server with CORS verification
const wss = new WebSocket.Server({ 
  port,
  maxPayload: MAX_MESSAGE_SIZE,
  verifyClient: (info) => {
    // Check connection limit first
    if (currentConnections >= MAX_CONNECTIONS) {
      console.log(`âŒ Rejected connection - max connections reached: ${currentConnections}/${MAX_CONNECTIONS}`);
      return false;
    }
    
    // Check origin
    const origin = info.origin;
    const isAllowed = allowedOrigins.includes(origin);
    
    if (!isAllowed) {
      console.log(`âŒ Rejected connection from unauthorized origin: ${origin}`);
      return false;
    }
    
    console.log(`âœ… Accepted connection from: ${origin} (${currentConnections + 1}/${MAX_CONNECTIONS})`);
    console.log('Model using:', DEFAULT_MODEL);
    return true;
  }
});

wss.on('connection', (ws, req) => {
  const clientOrigin = req.headers.origin;
  currentConnections++;
  console.log(`ðŸ”Œ New WebSocket connection from: ${clientOrigin} (${currentConnections}/${MAX_CONNECTIONS})`);
  
  let sessionId = null;
  let deepgramConnection = null;
  let isDeepgramConnected = false;
  let heartbeatInterval = null;
  let isAlive = true;

  // Simplified: directly use provided keywords list
  const parseAndNormalizeKeywords = (rawList) => {
    if (!Array.isArray(rawList)) return undefined;
    const cleaned = [];
    for (const item of rawList) {
      if (typeof item !== 'string') continue;
      const term = item.trim();
      if (!term || term.length < 2) continue;
      cleaned.push(term.includes(':') ? term : `${term}:1.5`);
      if (cleaned.length >= MAX_KEYTERMS) break;
    }
    return cleaned.length > 0 ? cleaned : undefined;
  };

  // Sanitize client-provided keyterms (plain strings, no weights)
  const sanitizeKeyterms = (rawList) => {
    if (!Array.isArray(rawList)) return undefined;
    const unique = new Set();
    for (const item of rawList) {
      if (typeof item !== 'string') continue;
      const term = item.trim();
      if (!term || term.length < 2) continue;
      unique.add(term);
      if (unique.size >= MAX_KEYTERMS) break;
    }
    return unique.size > 0 ? Array.from(unique) : undefined;
  };

  const extractKeyterms = (rawList) => {
    if (!Array.isArray(rawList)) return undefined;
    const terms = [];
    for (const item of rawList) {
      if (typeof item !== 'string') continue;
      const [termRaw] = item.split(':');
      const term = termRaw?.trim();
      if (!term || term.length < 2) continue;
      terms.push(term);
      if (terms.length >= MAX_KEYTERMS) break;
    }
    return terms.length > 0 ? terms : undefined;
  };

  // Helper: forward audio buffer to Deepgram with safety checks
  const forwardAudioToDeepgram = (buffer) => {
    const currentConnection = deepgramConnection;
    const currentConnectionState = isDeepgramConnected;
    if (!currentConnection || !currentConnectionState) {
      ws.send(JSON.stringify({
        type: 'error',
        error: 'Deepgram connection not ready',
        sessionId,
        code: 'DEEPGRAM_NOT_READY'
      }));
      return;
    }

    if (!Buffer.isBuffer(buffer)) {
      return;
    }

    if (buffer.length > MAX_AUDIO_BUFFER_SIZE) {
      ws.send(JSON.stringify({
        type: 'error',
        error: 'Audio buffer too large',
        sessionId,
        code: 'BUFFER_TOO_LARGE'
      }));
      return;
    }
    if (buffer.length === 0) return;

    try {
      currentConnection.send(buffer);
    } catch (sendError) {
      if (sendError.message?.includes('WebSocket is not open')) {
        isDeepgramConnected = false;
        ws.send(JSON.stringify({
          type: 'error',
          error: 'Deepgram connection closed during transmission',
          sessionId,
          code: 'CONNECTION_CLOSED'
        }));
      } else {
        throw sendError;
      }
    }
  };
  
  // Connection health monitoring
  const startHeartbeat = () => {
    // Send ping every 30 seconds
    heartbeatInterval = setInterval(() => {
      if (ws.readyState === ws.OPEN) {
        if (!isAlive) {
          console.log(`ðŸ’” Client ${sessionId} failed to respond to ping, terminating connection`);
          ws.terminate();
          return;
        }
        
        isAlive = false;
        ws.ping();
        console.log(`ðŸ’“ Sent heartbeat ping to session: ${sessionId}`);
      }
    }, 30000);
  };
  
  // Handle pong responses
  ws.on('pong', () => {
    isAlive = true;
    console.log(`ðŸ’š Received heartbeat pong from session: ${sessionId}`);
  });
  
  // Handle ping from client (respond with pong)
  ws.on('ping', () => {
    console.log(`ðŸ’› Received ping from session: ${sessionId}, sending pong`);
    ws.pong();
  });

  // Handle incoming WebSocket messages
  ws.on('message', async (message, isBinary) => {
    try {
      // Support binary audio frames directly for lower overhead
      if (isBinary) {
        forwardAudioToDeepgram(message);
        return;
      }

      const data = JSON.parse(message.toString());
      
      switch (data.type) {
        case 'start_session':
          // Generate secure session ID if not provided
          sessionId = data.sessionId || `ws_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`;
          console.log(`ðŸŽ¯ Starting/Refreshing Deepgram session: ${sessionId}`);
          
          // Always create a fresh Deepgram session for reliability
          // This ensures we don't use stale sessions
          if (deepgramConnection) {
            console.log(`ðŸ”„ Closing existing Deepgram connection for fresh session`);
            try {
              deepgramConnection.finish();
              deepgramConnections.delete(sessionId);
            } catch (error) {
              console.log(`âš ï¸ Error closing old connection:`, error);
            }
            isDeepgramConnected = false;
          }
          
          // Create Deepgram client and connection
          const deepgram = createClient(deepgramApiKey);
          const isNova3 = typeof DEFAULT_MODEL === 'string' && DEFAULT_MODEL.toLowerCase().startsWith('nova-3');

          // Prefer client-provided keyterms when available
          const rawClientKeyterms = Array.isArray(data.keyterms)
            ? data.keyterms
            : (data.context && Array.isArray(data.context.keyterms) ? data.context.keyterms : undefined);
          const incomingKeyterms = sanitizeKeyterms(rawClientKeyterms);

          // Fallback to current defaults when client keyterms are not provided
          const fallbackKeyterms = extractKeyterms(defaultKeywords);

          const liveOptions = {
            // Formatting & model
            model: DEFAULT_MODEL,
            language: STT_LANGUAGE,
            smart_format: true,
            punctuate: true,
            numerals: true,

            // Endpointing and utterance signaling
            interim_results: true,
            endpointing: ENDPOINTING_MS,
            vad_events: true,
            utterance_end_ms: UTTERANCE_END_MS,
            paragraphs: true,
          };

          // Attach contextual vocabulary (Nova-3 keyterm only, no legacy keywords)
          if (isNova3) {
            const selectedKeyterms = (incomingKeyterms && incomingKeyterms.length > 0)
              ? incomingKeyterms
              : (fallbackKeyterms && fallbackKeyterms.length > 0 ? fallbackKeyterms : undefined);
            if (selectedKeyterms && selectedKeyterms.length > 0) {
              liveOptions.keyterm = selectedKeyterms;
              // Log ALL raw keyterms received/provided for visibility (no slicing)
              if (Array.isArray(rawClientKeyterms) && rawClientKeyterms.length > 0) {
                const printableRaw = rawClientKeyterms.map(item => (typeof item === 'string' ? item : JSON.stringify(item)));
                console.log(`ðŸ§© Raw client keyterms for session ${sessionId} (${printableRaw.length} total):`, printableRaw.join(', '));
              } else {
                console.log(`ðŸ§© Raw default keyterms for session ${sessionId} (${defaultKeywords.length} total):`, defaultKeywords.join(', '));
              }
              console.log(`ðŸ§  Using ${incomingKeyterms ? 'client-provided' : 'default'} keyterms for session ${sessionId}:`, selectedKeyterms.join(', '));
            }
          }

          deepgramConnection = deepgram.listen.live(liveOptions);
          
          // Store connection
          deepgramConnections.set(sessionId, deepgramConnection);

          // Set up Deepgram event listeners
          deepgramConnection.on(LiveTranscriptionEvents.Open, () => {
            isDeepgramConnected = true;
            console.log(`ðŸŽ¤ Deepgram connected for session: ${sessionId}`);
            ws.send(JSON.stringify({
              type: 'deepgram_connected',
              sessionId
            }));
          });

          deepgramConnection.on(LiveTranscriptionEvents.Transcript, (data) => {
            // Check if we have the expected structure
            if (data && data.channel && data.channel.alternatives && data.channel.alternatives.length > 0) {
              const transcript = data.channel.alternatives[0].transcript;
              const confidence = data.channel.alternatives[0].confidence;
              
              if (transcript && transcript.trim().length > 0) {
                // Check if this is a final transcript from CloseStream finalization
                const isFromFinalize = data.from_finalize === true;
                
                if (isFromFinalize) {
                  console.log(`ðŸ FINAL TRANSCRIPT from CloseStream for session ${sessionId}:`, transcript);
                }
                
                // Track final transcripts during finalization
                if (data.is_final && finalizationPending.has(sessionId)) {
                  const pending = finalizationPending.get(sessionId);
                  pending.finalTranscripts.push({
                    transcript,
                    timestamp: Date.now()
                  });
                  pending.lastTranscriptTime = Date.now();
                  
                  console.log(`ðŸ“ Tracked final transcript for session ${sessionId}:`, transcript);
                  
                  // Reset timeout since we received a transcript
                  const timeout = finalizationTimeouts.get(sessionId);
                  if (timeout) {
                    clearTimeout(timeout);
                  }
                  
                  // Set new timeout (5 seconds from last transcript)
                  const newTimeout = setTimeout(() => {
                    console.log(`â° No more final transcripts for session ${sessionId} after 5 seconds`);
                    sendFinalizationComplete(sessionId, ws);
                  }, 5000);
                  
                  finalizationTimeouts.set(sessionId, newTimeout);
                }
                
                ws.send(JSON.stringify({
                  type: 'transcript',
                  transcript,
                  is_final: data.is_final,
                  speech_final: data.speech_final,
                  confidence,
                  confidence_accept: data.is_final ? (typeof confidence === 'number' ? confidence >= MIN_FINAL_CONFIDENCE : true) : true,
                  min_confidence: MIN_FINAL_CONFIDENCE,
                  words: data.channel.alternatives[0].words,
                  from_finalize: isFromFinalize,
                  sessionId
                }));
              }
            }
          });

          deepgramConnection.on(LiveTranscriptionEvents.Metadata, (data) => {
            ws.send(JSON.stringify({
              type: 'metadata',
              data,
              sessionId
            }));
          });

          deepgramConnection.on(LiveTranscriptionEvents.Error, (err) => {
            console.error(`âŒ Deepgram error for session ${sessionId}:`, err);
            ws.send(JSON.stringify({
              type: 'error',
              error: err.message,
              sessionId
            }));
          });

          deepgramConnection.on(LiveTranscriptionEvents.Close, () => {
            isDeepgramConnected = false;
            console.log(`ðŸ”š Deepgram stream closed for session: ${sessionId}`);
            
            // Send finalization complete if we were waiting for it
            if (finalizationPending.has(sessionId)) {
              console.log(`ðŸŽ‰ Stream closed, sending finalization complete for session: ${sessionId}`);
              sendFinalizationComplete(sessionId, ws);
            }
            
            // Notify client that Deepgram stream is closed but WebSocket stays alive
            ws.send(JSON.stringify({
              type: 'deepgram_stream_closed',
              sessionId,
              message: 'Deepgram stream finalized, ready for next session'
            }));
            
            // Don't delete the connection from the map yet - we might recreate it
            // deepgramConnections.delete(sessionId); // REMOVED - keep for potential restart
          });

          // Start heartbeat monitoring after session is established
          startHeartbeat();
          
          // Confirm session started
          ws.send(JSON.stringify({
            type: 'session_started',
            sessionId
          }));
          break;

        case 'audio_data':
          // Validate audio data format
          if (!data.audio || typeof data.audio !== 'string') {
            console.error(`âŒ Invalid audio data format for session ${sessionId}`);
            ws.send(JSON.stringify({
              type: 'error',
              error: 'Invalid audio data format',
              sessionId,
              code: 'INVALID_AUDIO_FORMAT'
            }));
            return;
          }

          // Send audio data directly to Deepgram with enhanced error handling
          try {
            const buffer = Buffer.from(data.audio, 'base64');
            forwardAudioToDeepgram(buffer);
          } catch (error) {
            console.error(`âŒ Failed to send audio data for session ${sessionId}:`, error);
            ws.send(JSON.stringify({
              type: 'error',
              error: 'Failed to process audio data',
              sessionId,
              code: 'AUDIO_PROCESSING_ERROR',
              details: error.message
            }));
          }
          break;

        case 'end_session':
          if (deepgramConnection) {
            try {
              console.log(`ðŸ›‘ Ending session: ${sessionId}`);
              deepgramConnection.finish();
              deepgramConnections.delete(sessionId);
            } catch (error) {
              console.error(`âŒ Error ending session ${sessionId}:`, error);
            }
          }
          break;

        case 'ping':
          // Handle client ping for connection health check
          ws.send(JSON.stringify({
            type: 'pong',
            sessionId,
            timestamp: Date.now()
          }));
          console.log(`ðŸ“ Responded to ping from session: ${sessionId}`);
          break;

        case 'pong':
          // Client responded to our ping
          isAlive = true;
          console.log(`âœ… Received pong response from session: ${sessionId}`);
          break;

        case 'keep_alive':
          // Forward KeepAlive to Deepgram
          if (deepgramConnection && isDeepgramConnected) {
            try {
              deepgramConnection.keepAlive();
              console.log(`ðŸ«€ Forwarded KeepAlive to Deepgram for session: ${sessionId}`);
            } catch (error) {
              console.error(`âŒ Failed to send KeepAlive for session ${sessionId}:`, error);
            }
          }
          break;

        case 'close_stream':
          // Send CloseStream message to Deepgram to get final transcripts
          if (deepgramConnection && isDeepgramConnected) {
            try {
              console.log(`ðŸ Sending CloseStream to Deepgram for session: ${sessionId}`);
              
              // Mark this session as pending finalization
              finalizationPending.set(sessionId, {
                startTime: Date.now(),
                finalTranscripts: [],
                lastTranscriptTime: Date.now()
              });
              
              // Send the CloseStream message as per Deepgram docs
              const closeStreamMsg = JSON.stringify({ type: 'CloseStream' });
              deepgramConnection.send(closeStreamMsg);
              
              console.log(`âœ… CloseStream message sent for session: ${sessionId}`);
              
              // Notify client that CloseStream was sent
              ws.send(JSON.stringify({
                type: 'close_stream_sent',
                sessionId,
                message: 'Waiting for final transcripts'
              }));
              
              // Set up finalization timeout (10 seconds)
              const finalizationTimeout = setTimeout(() => {
                console.log(`â° Finalization timeout reached for session: ${sessionId}`);
                sendFinalizationComplete(sessionId, ws);
              }, 10000); // 10 seconds timeout
              
              finalizationTimeouts.set(sessionId, finalizationTimeout);
              
            } catch (error) {
              console.error(`âŒ Failed to send CloseStream for session ${sessionId}:`, error);
              ws.send(JSON.stringify({
                type: 'error',
                error: 'Failed to close Deepgram stream',
                sessionId,
                code: 'CLOSE_STREAM_ERROR'
              }));
            }
          } else {
            console.warn(`âš ï¸ CloseStream requested but Deepgram not connected for session ${sessionId}`);
            ws.send(JSON.stringify({
              type: 'error',
              error: 'Deepgram not connected',
              sessionId,
              code: 'DEEPGRAM_NOT_CONNECTED'
            }));
          }
          break;

        case 'finalize':
          // Send Finalize message to Deepgram to flush and get final transcripts without closing stream
          if (deepgramConnection && isDeepgramConnected) {
            try {
              console.log(`âœ… Sending Finalize to Deepgram for session: ${sessionId}`);

              // Mark this session as pending finalization (reuse same tracking)
              finalizationPending.set(sessionId, {
                startTime: Date.now(),
                finalTranscripts: [],
                lastTranscriptTime: Date.now()
              });

              const finalizeMsg = JSON.stringify({ type: 'Finalize' });
              deepgramConnection.send(finalizeMsg);

              ws.send(JSON.stringify({
                type: 'finalize_sent',
                sessionId,
                message: 'Waiting for final transcripts'
              }));

              // Use same timeout window as close_stream
              const finalizeTimeout = setTimeout(() => {
                console.log(`â° Finalize timeout reached for session: ${sessionId}`);
                sendFinalizationComplete(sessionId, ws);
              }, 10000);
              finalizationTimeouts.set(sessionId, finalizeTimeout);
            } catch (error) {
              console.error(`âŒ Failed to send Finalize for session ${sessionId}:`, error);
              ws.send(JSON.stringify({
                type: 'error',
                error: 'Failed to finalize Deepgram stream',
                sessionId,
                code: 'FINALIZE_ERROR'
              }));
            }
          } else {
            console.warn(`âš ï¸ Finalize requested but Deepgram not connected for session ${sessionId}`);
            ws.send(JSON.stringify({
              type: 'error',
              error: 'Deepgram not connected',
              sessionId,
              code: 'DEEPGRAM_NOT_CONNECTED'
            }));
          }
          break;

        default:
          console.log(`â“ Unknown message type: ${data.type}`);
          break;
      }
    } catch (error) {
      console.error('âŒ Error processing message:', error);
      ws.send(JSON.stringify({
        type: 'error',
        error: 'Invalid message format'
      }));
    }
  });

  // Centralized cleanup function
  const cleanupConnection = () => {
    console.log(`ðŸ§¹ Cleaning up session: ${sessionId}`);
    
    // Decrement connection count
    currentConnections = Math.max(0, currentConnections - 1);
    console.log(`ðŸ“Š Connections: ${currentConnections}/${MAX_CONNECTIONS}`);
    
    // Clean up heartbeat interval
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
      heartbeatInterval = null;
      console.log(`ðŸ’” Stopped heartbeat for session: ${sessionId}`);
    }
    
    // Clean up finalization tracking
    if (sessionId) {
      const timeout = finalizationTimeouts.get(sessionId);
      if (timeout) {
        clearTimeout(timeout);
        finalizationTimeouts.delete(sessionId);
      }
      finalizationPending.delete(sessionId);
    }
    
    // Clean up Deepgram connection
    if (deepgramConnection) {
      try {
        deepgramConnection.finish();
        if (sessionId) {
          deepgramConnections.delete(sessionId);
        }
      } catch (error) {
        console.error(`âŒ Error cleaning up session ${sessionId}:`, error);
      }
    }
  };

  // Handle WebSocket close
  ws.on('close', () => {
    console.log(`ðŸ”Œ WebSocket connection closed for session: ${sessionId}`);
    cleanupConnection();
  });

  // Handle WebSocket errors
  ws.on('error', (error) => {
    console.error(`âŒ WebSocket error for session ${sessionId}:`, error);
    cleanupConnection();
  });

  // Send initial connection confirmation
  ws.send(JSON.stringify({
    type: 'connected',
    message: 'WebSocket connection established'
  }));
});

// Handle server events
wss.on('listening', () => {
  console.log(`âœ… VRPlaced STT WebSocket Server listening on port ${port}`);
  console.log(`ðŸŒ Server ready to accept connections from allowed origins`);
});

wss.on('error', (error) => {
  console.error('âŒ WebSocket server error:', error);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Shutting down VRPlaced STT WebSocket Server...');
  
  // Close all active Deepgram connections
  console.log(`ðŸ§¹ Cleaning up ${deepgramConnections.size} active connections...`);
  deepgramConnections.forEach((connection, sessionId) => {
    try {
      connection.finish();
      console.log(`âœ… Cleaned up session: ${sessionId}`);
    } catch (error) {
      console.error(`âŒ Error cleaning up session ${sessionId}:`, error);
    }
  });
  
  // Close WebSocket server
  wss.close(() => {
    console.log('âœ… WebSocket server closed');
    process.exit(0);
  });
});

// Health check endpoint (for Railway)
const http = require('http');
const healthServer = http.createServer((req, res) => {
  if (req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ 
      status: 'healthy', 
      activeConnections: deepgramConnections.size,
      uptime: process.uptime()
    }));
  } else {
    res.writeHead(404);
    res.end('Not Found');
  }
});

// Start health check server on a different port
const healthPort = parseInt(port) + 1;
healthServer.listen(healthPort, () => {
  console.log(`ðŸ’Š Health check server running on port ${healthPort}`);
});